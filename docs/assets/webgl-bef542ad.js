import{a as f,p as M,d as S,b as U,m as w,i as B,e as P,t as F,r as I,s as v}from"./mat4-f2f89396.js";const d={texture:"texture",cubeTexture:"cubeTexture",normal:"normalMatrix",f3v:"f3v",f4v:"f4v",imageSource:"image",canvasSource:"canvas",videoSource:"video"},_=o=>o instanceof HTMLVideoElement,D=o=>o instanceof HTMLCanvasElement,C=o=>o instanceof HTMLImageElement,L=o=>C(o)||D(o)||_(o),b=o=>(o&o-1)===0,T=(o,e)=>Object.prototype.hasOwnProperty.call(o,e);class R{constructor(e=0,t=0,r=0){this.x=e,this.y=t,this.z=r}set(e,t,r){this.x=e,this.y=t,this.z=r}toArray(){const{x:e,y:t,z:r}=this;return[e,t,r]}}class p{constructor(e=0,t=0,r=0,s=0){this.x=e,this.y=t,this.z=r,this.w=s}set(e,t,r,s){this.x=e,this.y=t,this.z=r,this.w=s}toArray(){const{x:e,y:t,z:r,w:s}=this;return[e,t,r,s]}}class k{constructor(e,t){this.data=e,this.count=t}}class y{constructor(){this.position=new R,this.rotation=new R,this.scale=new R(1,1,1),this.modelMatrix=f()}rotateX(e){this.rotation.x=e}rotateY(e){this.rotation.y=e}rotateZ(e){this.rotation.z=e}computeModelMatrix(){const{position:e,rotation:t,scale:r}=this,s=[{axis:[1,0,0],rotation:t.x},{axis:[0,1,0],rotation:t.y},{axis:[0,0,1],rotation:t.z}],a=f();F(a,a,e.toArray());for(const i of s)I(a,a,i.rotation,i.axis);v(a,a,r.toArray()),this.modelMatrix=a}}class A{constructor(e){this.fov=S(e.fov),this.aspect=e.aspect,this.near=e.near,this.far=e.far,this.viewMatrix=f(),this.projectionMatrix=f(),this.position=new R,this.lookAtTarget=new R,this.up=new R(0,1,0)}lookAt(e,t,r){this.lookAtTarget.set(e,t,r)}setAspect(e){this.aspect=e}computeViewMatrix(){const{position:e,lookAtTarget:t,up:r}=this,s=f();U(s,e.toArray(),t.toArray(),r.toArray()),this.viewMatrix=s}}class V extends A{constructor(e){super(e),this.projectionMatrix=this.computeProjectionMatrix()}computeProjectionMatrix(){const{fov:e,aspect:t,near:r,far:s}=this,a=f();return M(a,e,t,r,s),a}}class l{constructor(e){const{resource:t=null,width:r=0,height:s=0,frameUpdate:a}=e;if(!(t?L(t):r&&s))throw new Error("texture resource must be canvas、image、video or resource is null but need width and height");const n=!!t;this.width=n?t.width:r,this.height=n?t.height:s,this.resource=n?t:null,this.frameUpdate=!!a,this.initial=!1}init(e){this.initial||(this.source=this.resource?this.createTextureFromSource(e):this.createNullDataTexture(e),this.initial=!0)}updateTexture(e){const{source:t,resource:r}=this;!t||!r||(e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r))}createNullDataTexture(e){const{width:t,height:r}=this,s=e.createTexture();return e.bindTexture(e.TEXTURE_2D,s),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,r,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),s}createTextureFromSource(e){const t=this.resource,r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t);const s=_(t);return b(t.width)&&b(t.height)&&!s?e.generateMipmap(e.TEXTURE_2D):(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR)),r}}class N{constructor(e){if(!(Array.isArray(e)&&e.length===6))throw new Error("cube texture resource must be a array and length is 6");this.resources=e}init(e){this.source=this.createCubeTextureFromSource(e)}createCubeTextureFromSource(e){const t=this.resources,r=e.createTexture();e.bindTexture(e.TEXTURE_CUBE_MAP,r);const s=[e.TEXTURE_CUBE_MAP_POSITIVE_Y,e.TEXTURE_CUBE_MAP_NEGATIVE_Y,e.TEXTURE_CUBE_MAP_NEGATIVE_X,e.TEXTURE_CUBE_MAP_POSITIVE_X,e.TEXTURE_CUBE_MAP_POSITIVE_Z,e.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let a=0,i=s.length;a<i;a++){const n=s[a],h=t[a];e.texImage2D(n,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,h)}return e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),r}}class j{constructor(){this.attributes={},this.vertexCount=0}setAttribute(e,t){if(!["aPosition","aColor","aUV","aNormal"].includes(e))throw new Error("An error occurred setAttribute");this.attributes[e]=t}setIndex(e){this.indices=e}init(e,t){this.processBuffers(e),this.processVertexAttrib(e,t)}processBuffers(e){const t=this.attributes||{},r={},s=e.ARRAY_BUFFER;let a=0;for(const[h,u]of Object.entries(t))h==="aPosition"&&(a=u.data.length/u.count),r[h]=this.createBuffer(e,s,u.data);this.buffers=r;const i=this.indices,n=i&&i.length>0;n&&(this.indexBuffer=this.createBuffer(e,e.ELEMENT_ARRAY_BUFFER,i)),this.vertexCount=n?i.length:a}processVertexAttrib(e,t){const{buffers:r,attributes:s}=this,a={};for(const[i,n]of Object.entries(r)){const{count:h}=s[i],u=e.getAttribLocation(t,i);a[i]={count:h,buffer:n,location:u}}this.vertexAttributesInfo=a}createBuffer(e,t,r){const s=e.createBuffer();return e.bindBuffer(t,s),e.bufferData(t,r,e.STATIC_DRAW),s}}class H{constructor(e){this.vertexSource=e.vertex,this.fragmentSource=e.fragment,this.resources=e.resources,this.depthTest=e.depthTest||{},this.stencilTest=e.stencilTest||{},this.blend=e.blend||{}}init(e){this.program=this.createProgram(e),this.processResources(e),this.processStencil(e),this.processDepth(e),this.processBlend()}processStencil(e){const t=this.stencilTest;this.stencilTest={enable:T(t,"enable")?!!t.enable:!1,stencilFunc:T(t,"stencilFunc")?t.stencilFunc:e.ALWAYS,stencilMask:T(t,"stencilMask")?t.stencilMask:255,stencilRef:T(t,"stencilRef")?t.stencilRef:0,stencilPass:T(t,"stencilPass")?t.stencilPass:e.KEEP}}processDepth(e){const t=this.depthTest;this.depthTest={enable:T(t,"enable")?!!t.enable:!0,depthWrite:T(t,"depthWrite")?!!t.depthWrite:!0,depthFunc:T(t,"depthFunc")?t.depthFunc:e.LESS}}processBlend(){const e=this.blend;this.blend={enable:T(e,"enable")?!!e.enable:!1}}processResources(e){const{program:t,resources:r={}}=this,s={},a={[d.texture]:i=>{if(!(i instanceof l))throw new Error("Shader Resources Texture must be a Texture Instance");return i.init(e),{value:i}},[d.cubeTexture]:i=>{if(!(i instanceof N))throw new Error("Shader Resources CubeTexture must be a CubeTexture Instance");return i.init(e),{value:i}}};for(const[i,n]of Object.entries(r)){const h=n.value,x={location:e.getUniformLocation(t,i),type:n.type,value:h},m=a[n.type],c=m?m(h):{};s[i]={...x,...c}}this.uniformsInfo=s}createProgram(e){const{vertexSource:t,fragmentSource:r}=this,s=this.createShader(e,e.VERTEX_SHADER,t),a=this.createShader(e,e.FRAGMENT_SHADER,r),i=e.createProgram();if(e.attachShader(i,s),e.attachShader(i,a),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS))return i;throw e.deleteProgram(i),new Error("Unable to initialize the shader program")}createShader(e,t,r){const s=e.createShader(t);if(e.shaderSource(s,r),e.compileShader(s),e.getShaderParameter(s,e.COMPILE_STATUS))return s;throw e.deleteShader(s),new Error("An error occurred compiling the shaders")}}class X extends y{constructor(e){super(),this.geometry=e.geometry,this.shader=e.shader}init(e){const{shader:t,geometry:r}=this;t.init(e),r.init(e,t.program);const s=t.program;this.defaultUniforms={uModelMatrix:e.getUniformLocation(s,"uModelMatrix"),uViewMatrix:e.getUniformLocation(s,"uViewMatrix"),uProjectionMatrix:e.getUniformLocation(s,"uProjectionMatrix")},this.isDrawElements=!!r.indexBuffer}render(e,t){this.computeModelMatrix(),e.useProgram(this.shader.program),this.updateAttributes(e),this.updateUniforms(e,t)}computeNormalMatrix(e){const t=this.modelMatrix,r=f();w(r,e,t);const s=f();return B(s,r),P(s,s),s}updateAttributes(e){const{vertexAttributesInfo:t,indexBuffer:r}=this.geometry;for(const s of Object.values(t)){const{count:a,location:i,buffer:n}=s;e.bindBuffer(e.ARRAY_BUFFER,n),e.vertexAttribPointer(i,a,e.FLOAT,!1,0,0),e.enableVertexAttribArray(i)}r&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r)}updateUniforms(e,t){const{modelMatrix:r,defaultUniforms:s,shader:a}=this,{viewMatrix:i,projectionMatrix:n}=t,h=a.uniformsInfo;let u=0;e.uniformMatrix4fv(s.uModelMatrix,!1,r),e.uniformMatrix4fv(s.uViewMatrix,!1,i),e.uniformMatrix4fv(s.uProjectionMatrix,!1,n);const x={[d.texture]:c=>{const E=c.value;e.activeTexture(e.TEXTURE0+u),e.bindTexture(e.TEXTURE_2D,E.source),e.uniform1i(c.location,u),u+=1,E.frameUpdate&&E.updateTexture(e)},[d.normal]:c=>{const E=this.computeNormalMatrix(i);e.uniformMatrix4fv(c.location,!1,E)},[d.f3v]:c=>{e.uniform3fv(c.location,c.value)},[d.f4v]:c=>{e.uniform4fv(c.location,c.value)},[d.cubeTexture]:c=>{e.activeTexture(e.TEXTURE0),e.uniform1i(c.location,0)}},m=Object.values(h);if(Array.isArray(m)&&m.length>0)for(const c of m){const E=x[c.type];E&&E(c)}}}class O{constructor(e,t){this.width=e,this.height=t,this.texture=new l({width:e,height:t}),this.depthStencilBuffer=null,this.frameBuffer=null,this.initial=!1}init(e){if(this.initial)return;this.texture.init(e),this.frameBuffer=this.createFrameBuffer(e),this.bindFramebufferAndSetViewport(e),this.depthStencilBuffer=this.createDepthStencilRenderBuffer(e),this.bindAttachment(e);const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(e.FRAMEBUFFER_COMPLETE!==t)throw this.destroy(e),new Error("Frame buffer object is incomplete: "+t.toString());this.initial=!0}destroy(e){const{depthBuffer:t,stencilBuffer:r,frameBuffer:s}=this;t&&e.deleteRenderbuffer(t),r&&e.deleteRenderbuffer(r),s&&e.deleteFramebuffer(s)}createDepthStencilRenderBuffer(e){const{width:t,height:r}=this,s=e.createRenderbuffer();return e.bindRenderbuffer(e.RENDERBUFFER,s),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_STENCIL,t,r),s}createFrameBuffer(e){return e.createFramebuffer()}bindFramebufferAndSetViewport(e){e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),e.viewport(0,0,this.width,this.height)}bindAttachment(e){e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture.source,0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.RENDERBUFFER,this.depthStencilBuffer)}}class W{constructor(e){const{canvas:t,autoClear:r=!0,antialias:s=!0}=e;this.canvas=e.canvas,this.autoClear=!!r;const a=t.getContext("webgl",{antialias:!!s});if(this.gl=a,!a)throw new Error("WebGL not supported");this.scissor=null,this.depthTest=!0,this.stencilTest=!1,this.viewport=new p(0,0,this.canvas.width,this.canvas.height),this.background=new p(0,0,0,1)}drawElements(e){const t=this.gl;t.drawElements(t.TRIANGLES,e,t.UNSIGNED_SHORT,0)}drawArrays(e){const t=this.gl;t.drawArrays(t.TRIANGLES,0,e)}setScissor(e,t,r,s){this.scissor=new p(e,t,r,s)}setDepthTest(e){this.depthTest=!!e}setStencilTest(e){this.stencilTest=!!e}renderToTarget(){const{viewport:e,gl:t,renderTarget:r}=this;r?r.bindFramebufferAndSetViewport(t):(t.viewport(e.x,e.y,e.z,e.w),t.bindFramebuffer(t.FRAMEBUFFER,null))}setViewport(e,t,r,s){this.viewport.set(e,t,r,s)}setBackground(e,t,r,s){this.background.set(e,t,r,s)}clear(){const{gl:e,background:t,scissor:r}=this;this.renderToTarget(),e.clearColor(t.x,t.y,t.z,t.w),e.clearDepth(1),r?(e.enable(e.SCISSOR_TEST),e.scissor(r.x,r.y,r.z,r.w)):e.disable(e.SCISSOR_TEST),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT|e.STENCIL_BUFFER_BIT)}startStencilTest(e){const{gl:t}=this;if(!e||!e.enable){t.disable(t.STENCIL_TEST);return}t.enable(t.STENCIL_TEST),t.disable(t.DEPTH_TEST),t.stencilMask(e.stencilMask),t.stencilFunc(e.stencilFunc,e.stencilRef,255),t.stencilOp(t.KEEP,t.KEEP,e.stencilPass)}startDepthTest(e){const{gl:t,depthTest:r}=this;if(!r||!e||!e.enable){t.disable(t.DEPTH_TEST);return}t.enable(t.DEPTH_TEST),t.depthFunc(e.depthFunc),t.depthMask(e.depthWrite)}startBlend(e){const t=this.gl;if(!e||!e.enable){t.disable(t.BLEND);return}t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA)}renderScene(e,t){if(!e||Array.isArray(e)&&e.length===0)return;const{gl:r}=this,{viewMatrix:s,projectionMatrix:a}=t,i=Array.isArray(e)?e:[e];for(const n of i){if(!(n instanceof X)){console.warn("Mesh TypeError");break}const{geometry:h,shader:u}=n;n.render(r,{viewMatrix:s,projectionMatrix:a});const x=h.vertexCount;this.startDepthTest(u.depthTest),this.startStencilTest(u.stencilTest),this.startBlend(u.blend),n.isDrawElements?this.drawElements(x):this.drawArrays(x)}}setRenderTarget(e){const t=e&&e instanceof O?e:null;t&&t.init(this.gl),this.renderTarget=t}render(e,t){if(!(t instanceof A))throw new Error("Camera TypeError");t.computeViewMatrix(),this.autoClear&&this.clear(),this.renderScene(e,t)}}export{k as B,N as C,j as G,X as M,y as O,V as P,O as R,H as S,l as T,W};
