import{c as p,a as c,b as v,p as A}from"./mat4-f2f89396.js";import{B as w,O as S}from"./webgl-bef542ad.js";import{r as E,o as P,b as R,a as _,c as B}from"./index-9023bf6a.js";const j={__name:"ProjectionMatrix",setup(g){const u=E(null),h=()=>{const i=u.value,t=i.getBoundingClientRect(),e=p(t.width,t.height);return i.appendChild(e),{canvas:e,bounds:t}};class f{constructor(){this.attributes={},this.vertexCount=0}setAttribute(t,e){if(!["aPosition"].includes(t))throw new Error("An error occurred setAttribute");this.attributes[t]=e}setIndex(t){this.indices=t,this.vertexCount=t.length}init(t,e){this.processBuffers(t),this.processVertexAttrib(t,e)}processBuffers(t){const e=this.attributes,r={},o=t.ARRAY_BUFFER;let a=0;for(const[s,n]of Object.entries(e))s==="aPosition"&&(a=n.data.length/n.count),r[s]=this.createBuffer(t,o,n.data);this.buffers=r,this.vertexCount=a}processVertexAttrib(t,e){const{buffers:r,attributes:o}=this,a={};for(const[s,n]of Object.entries(r)){const{count:M}=o[s],b=t.getAttribLocation(e,s);a[s]={count:M,buffer:n,location:b}}this.vertexAttributesInfo=a}createBuffer(t,e,r){const o=t.createBuffer();return t.bindBuffer(e,o),t.bufferData(e,r,t.STATIC_DRAW),o}}class d{constructor(t){this.vertexSource=t.vertex,this.fragmentSource=t.fragment}init(t){this.program=this.createProgram(t)}createProgram(t){const{vertexSource:e,fragmentSource:r}=this,o=this.createShader(t,t.VERTEX_SHADER,e),a=this.createShader(t,t.FRAGMENT_SHADER,r),s=t.createProgram();if(t.attachShader(s,o),t.attachShader(s,a),t.linkProgram(s),t.getProgramParameter(s,t.LINK_STATUS))return s;throw t.deleteProgram(s),new Error("Unable to initialize the shader program")}createShader(t,e,r){const o=t.createShader(e);if(t.shaderSource(o,r),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS))return o;throw t.deleteShader(o),new Error("An error occurred compiling the shaders")}}class m extends S{constructor(t){super(),this.geometry=t.geometry,this.shader=t.shader}init(t){const{shader:e,geometry:r}=this;e.init(t),r.init(t,e.program);const o=e.program;this.defaultUniforms={uModelMatrix:t.getUniformLocation(o,"uModelMatrix"),uViewMatrix:t.getUniformLocation(o,"uViewMatrix"),uProjectionMatrix:t.getUniformLocation(o,"uProjectionMatrix")}}render(t,e){this.computeModelMatrix(),t.useProgram(this.shader.program),this.updateAttributes(t),this.updateUniforms(t,e)}updateAttributes(t){const{vertexAttributesInfo:e}=this.geometry;for(const r of Object.values(e)){const{count:o,location:a,buffer:s}=r;t.bindBuffer(t.ARRAY_BUFFER,s),t.vertexAttribPointer(a,o,t.FLOAT,!1,0,0),t.enableVertexAttribArray(a)}}updateUniforms(t,e){const r=this.modelMatrix,o=this.defaultUniforms,{viewMatrix:a,projectionMatrix:s}=e;t.uniformMatrix4fv(o.uModelMatrix,!1,r),t.uniformMatrix4fv(o.uViewMatrix,!1,a),t.uniformMatrix4fv(o.uProjectionMatrix,!1,s)}}class x{constructor(t){const{canvas:e}=t;this.canvas=t.canvas;const r=e.getContext("webgl");if(this.gl=r,!r)throw new Error("WebGL not supported");this.viewMatrix=c(),this.projectionMatrix=this.createProjectMatrix()}setViewMatrix(t,e,r){const o=c();v(o,t,e,r),this.viewMatrix=o}createProjectMatrix(){const t=this.canvas,e=45*Math.PI/180,r=t.clientWidth/t.clientHeight,o=.1,a=100,s=c();return A(s,e,r,o,a),s}drawElements(t){const e=this.gl;e.drawElements(e.TRIANGLES,t,e.UNSIGNED_SHORT,0)}drawArrays(t){const e=this.gl;e.drawArrays(e.TRIANGLES,0,t)}renderStart(){const{gl:t,canvas:e}=this;t.viewport(0,0,e.width,e.height),t.clearColor(0,0,0,1),t.clearDepth(1),t.enable(t.DEPTH_TEST),t.depthFunc(t.LEQUAL),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT)}renderScene(t){const{gl:e,viewMatrix:r,projectionMatrix:o}=this;t.render(e,{viewMatrix:r,projectionMatrix:o}),this.drawArrays(t.geometry.vertexCount)}render(t){this.renderStart(),this.renderScene(t)}}const l=i=>{const t=new f,e=new Float32Array([0,0,0,10,18,0]);t.setAttribute("aPosition",new w(e,2));const r=new m({geometry:t,shader:new d({vertex:`
        precision mediump float;
        attribute vec3 aPosition;
        uniform mat4 uModelMatrix;
        uniform mat4 uViewMatrix;
        uniform mat4 uProjectionMatrix;
        void main() {
          gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
        }
      `,fragment:`
        precision mediump float;
        void main() {
          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
      `})});return r.init(i),r};return P(()=>{let i=null;const{canvas:t}=h(),e=new x({canvas:t}),r=l(e.gl);r.position.set(0,0,-30);const o=[0,0,-80];e.setViewMatrix(o,[0,0,0],[0,1,0]);const a=()=>{r.rotateY(r.rotation.y+.01),e.render(r),i=window.requestAnimationFrame(a)};a(),R(()=>window.cancelAnimationFrame(i))}),(i,t)=>(_(),B("div",{ref_key:"boxElementRef",ref:u,class:"box"},null,512))}};export{j as default};
